#!/opt/perl/bin/perl

use 5.028;

use strict;
use warnings;
no  warnings 'syntax';

use experimental 'signatures';
use experimental 'lexical_subs';

use lib "../lib";

use Getopt::Long;

use Chess::Infinite;

GetOptions  "piece=s"      =>  \(my $piece_name = "knight"),
            "board=s"      =>  \(my $board_name = "spiral"),
            "start=i"      =>  \(my $start      =  1),
            "max_moves=i"  =>  \(my $max_moves  =  10_000),
;

$board_name = fc $board_name;
$piece_name = fc $piece_name;

my %board2class = (
    fc spiral      =>  "Spiral"
);

my %piece2class = (
    fc knight           =>  "Knight",
    fc kn               =>  "Knight",
    fc ferz             =>  "Ferz",
    fc camel            =>  "Camel",
    fc alfil            =>  "Alfil",
    fc king             =>  "King",
    fc drunken_elephant =>  "DrunkenElephant",
);

die "'$board_name': no such board\n" unless    $board2class {$board_name};
die "'$piece_name': no such piece\n" unless    $piece2class {$piece_name};

my $board_class = "Chess::Infinite::Board::" . $board2class {$board_name};
my $piece_class = "Chess::Infinite::Piece::" . $piece2class {$piece_name};

my $board = $board_class -> new -> init;
my $piece = $piece_class -> new -> init (board  =>  $board,
                                         start  =>  $start,);


my $move_count = 0;
while ($move_count ++ < $max_moves) {
    if (!$piece -> move) {
        my ($x, $y) = $piece -> position;
        printf "%s trapped on value %d (%d, %d) after %d moves.\n",
                ucfirst lc $piece -> name,
                $board -> to_value ($x, $y), $x, $y, $move_count;
        last;
    }
}

=pod

my ($x, $y) = $piece -> position;
printf "%s on value %d (%d, %d) after %d moves.\n" =>
         ucfirst lc $piece -> name,
         $board -> to_value ($x, $y), $x, $y, $move_count - 1;

=cut


Chess::Infinite::Grapher:: -> route (piece => $piece);


__END__
